# These are usually in a file named .rsync-filter.
#
# rsync -F -irvt -n source destination
# rsync -F -F -irvt -n source destination
# rsync -virtn --filter="merge ~/rsync-filter"
#
# The first pattern which matches decides the action.
# If no pattern matches then the file is included.

# exclude, - specifies an exclude pattern.
# include, + specifies an include pattern.
# merge, . specifies a merge-file to read for more rules.
# dir-merge, : specifies a per-directory merge-file.
# hide, H specifies a pattern for hiding files from the transfer.
# show, S files that match the pattern are not hidden.
# protect, P specifies a pattern for protecting files from deletion.
# risk, R files that match the pattern are not protected.
# clear, ! clears the current include/exclude list (takes no arg)
# If the pattern starts with a / then it is anchored to a particular
# spot in the hierarchy of files, otherwise it is matched against
# the end of the pathname. This is similar to a leading ^ in regular
# expressions. Thus "/foo" would match a name of "foo" at either
# the "root of the transfer" (for a global rule) or in the
# merge-file’s directory (for a per-directory rule).



# If the pattern ends with a / then it will only match a directory, not a regular
# file, symlink, or device.
#
# rsync chooses between doing a simple string match and wildcard matching by checking
# if the pattern contains one of these three wildcard characters: ’*’, ’?’, and ’[’ .
#
# A ’*’ matches any path component, but it stops at slashes.
#
# Use ’**’ to match anything, including slashes.
#
# A ’?’ matches any character except a slash (/).
#
# A ’[’ introduces a character class, such as [a-z] or [[:alpha:]].
#
# In a wildcard pattern, a backslash can be used to escape a wildcard character, but
# it is matched literally when no wildcards are present. This means that there is an
# extra level of backslash removal when a pattern contains wildcard characters com‐
# pared to a pattern that has none. e.g. if you add a wildcard to "foo\bar" (which
# matches the backslash) you would need to use "foo\\bar*" to avoid the "\b" becoming
# just "b".
#
# If the pattern contains a / (not counting a trailing /) or a "**", then it is
# matched against the full pathname, including any leading directories. If the pattern
# doesn’t contain a / or a "**", then it is matched only against the final component
# of the filename. (Remember that the algorithm is applied recursively so "full file‐
# name" can actually be any portion of a path from the starting directory on down.)
#
# A trailing "dir_name/***" will match both the directory (as if "dir_name/" had been
# specified) and everything in the directory (as if "dir_name/**" had been specified).
# This behavior was added in version 2.6.7.

exclude .git/
exclude .*sw[op]
exclude *.gz
exclude *.zip
exclude *.tgz
exclude *.log
exclude *.pdf
exclude *.ps
exclude *~
exclude .*
exclude *xcf
exclude *.sh
exclude *.bash

